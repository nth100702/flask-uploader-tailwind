from datetime import datetime
import pytz
from app import db, app


"""SqlAlchemy database models
"""
def now():
    return datetime.now(tz=pytz.timezone("Asia/Ho_Chi_Minh"))

class ChunkedFile(db.Model):
    __tablename__ = "chunked_file"
    id = db.Column(db.Integer, primary_key=True)
    # dz fields
    dzuuid = db.Column(db.String(100), nullable=False)  # unique ID per upload file
    dzchunkindex = db.Column(
        db.Integer, nullable=False
    )  # the chunk number of the current upload
    dzchunksize = db.Column(db.Integer, nullable=False)
    dztotalfilesize = db.Column(db.Integer, nullable=False)
    dztotalchunkcount = db.Column(db.Integer, nullable=False)
    dzchunkbyteoffset = db.Column(
        db.Integer, nullable=False
    )  # The place in the file this chunk starts
    # file fields
    chunkpath = db.Column(db.String(100), nullable=False)
    # others
    created_at = db.Column(db.DateTime, nullable=False, default=now())

    # foreign key
    file_upload_id = db.Column(
        db.Integer, db.ForeignKey("file_upload.id"), nullable=False
    )

    def __repr__(self):
        return f"ChunkedFile('{self.dzuuid}', '{self.created_at}')"


class FileUpload(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(100), nullable=False)
    filepath = db.Column(db.String(100), nullable=False)
    # keep track of chunks
    total_chunks = db.Column(db.Integer, nullable=False)
    chunks_received = db.Column(db.Integer, default=0)
    file_reassembled = db.Column(db.Boolean, default=False) # on local server's filesystem
    # timestamp, tz = gmt+7 (vietnam)
    created_at = db.Column(db.DateTime, nullable=False, default=now()) # server received
    onedrive_uploaded_at = db.Column(db.DateTime) # server uploaded the file to oneDrive

    # a file upload has many chunked files
    chunked_files = db.relationship("ChunkedFile", backref="file_upload")

    # each file upload belongs to a submit record
    submit_record_id = db.Column(
        db.Integer, db.ForeignKey("submit_record.id"), nullable=False
    )

    def __repr__(self):
        return f"FileUpload('{self.filename}', '{self.uploaded_at}')"


class SubmitRecord(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    submit_id_frontend = db.Column(db.String(100), nullable=False)
    files_received = db.Column(db.Integer, nullable=False, default=0)
    onedrive_files_uploaded = db.Column(db.Integer, nullable=False, default=0) # not yet implemented
    created_at = db.Column(db.DateTime, nullable=False, default=now())
    # each submit record has one submitter
    submitter_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    # each submit record has many file uploads
    file_uploads = db.relationship("FileUpload", backref="submit_record")

    def __repr__(self):
        return f"SubmitRecord('{self.submitted_at}', '{self.all_files_uploaded}')"


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    employee_id = db.Column(db.String(100), nullable=False)
    full_name = db.Column(db.String(100), nullable=False)
    department = db.Column(db.String(100), nullable=False)
    division = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), nullable=False)
    phone = db.Column(db.String(100), nullable=False)
    # autogenerated
    date_created = db.Column(db.DateTime, nullable=False, default=now())

    # each user has one or more submit records
    submit_records = db.relationship("SubmitRecord", backref="user")

    def __repr__(self):
        return f"User('{self.employee_id}', '{self.full_name}', '{self.division}')"

"""TO-DO:
Implememt OneDriveFileUpload model
"""
# 
# from sqlalchemy_utils import EncryptedType
# from cipher import cipher_suite
# class Session(db.Model):
#     id = db.Column(db.Integer, primary_key=True)
#     msgraph_access_token = db.Column(EncryptedType(db.String, cipher_suite))
#     msgraph_auth_response = db.Column(EncryptedType(db.String, cipher_suite))

"""
You have to create db tables WITHIN the flask app context
Else you will get an error like this: RuntimeError(unbound_message) from None RuntimeError: Working outside of application context.
Solution: Use app's context manager to create db tables
"""